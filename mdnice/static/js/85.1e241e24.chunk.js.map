{"version":3,"sources":["../node_modules/_codemirror@5.65.12@codemirror/mode/python/python.js"],"names":["CodeMirror","wordRegexp","words","RegExp","join","str","wordOperators","commonKeywords","commonBuiltins","top","state","scopes","length","registerHelper","concat","defineMode","conf","parserConf","ERRORCLASS","delimiters","singleDelimiters","operators","singleOperators","doubleOperators","doubleDelimiters","tripleDelimiters","i","splice","hangingIndent","indentUnit","myKeywords","myBuiltins","undefined","extra_keywords","extra_builtins","py3","version","Number","identifiers","stringPrefixes","keywords","builtins","tokenBase","stream","sol","lastToken","indent","indentation","type","scopeOffset","offset","eatSpace","lineOffset","pushPyScope","dedent","peek","errorToken","style","tokenBaseInner","inFormat","match","floatLiteral","eat","intLiteral","isFmtString","current","toLowerCase","indexOf","tokenize","delimiter","tokenOuter","charAt","substr","singleline","OUTCLASS","tokenNestedExpr","depth","inner","tokenString","eol","eatWhile","next","singleLineStringErrors","isString","formatStringFactory","tokenStringFactory","pop","push","align","indented","tokenLexer","beginningOfLine","test","lambda","delimiter_index","column","pushBracketScope","slice","external","startState","basecolumn","token","addErr","textAfter","Pass","scope","closing","electricInput","closeBrackets","triples","lineComment","fold","defineMIME","name","split","mod","__webpack_require__"],"mappings":"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","file":"static/js/85.1e241e24.chunk.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\")\n    // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd)\n    // AMD\n    define([\"../../lib/codemirror\"], mod);else\n    // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  function wordRegexp(words) {\n    return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\");\n  }\n  var wordOperators = wordRegexp([\"and\", \"or\", \"not\", \"is\"]);\n  var commonKeywords = [\"as\", \"assert\", \"break\", \"class\", \"continue\", \"def\", \"del\", \"elif\", \"else\", \"except\", \"finally\", \"for\", \"from\", \"global\", \"if\", \"import\", \"lambda\", \"pass\", \"raise\", \"return\", \"try\", \"while\", \"with\", \"yield\", \"in\", \"False\", \"True\"];\n  var commonBuiltins = [\"abs\", \"all\", \"any\", \"bin\", \"bool\", \"bytearray\", \"callable\", \"chr\", \"classmethod\", \"compile\", \"complex\", \"delattr\", \"dict\", \"dir\", \"divmod\", \"enumerate\", \"eval\", \"filter\", \"float\", \"format\", \"frozenset\", \"getattr\", \"globals\", \"hasattr\", \"hash\", \"help\", \"hex\", \"id\", \"input\", \"int\", \"isinstance\", \"issubclass\", \"iter\", \"len\", \"list\", \"locals\", \"map\", \"max\", \"memoryview\", \"min\", \"next\", \"object\", \"oct\", \"open\", \"ord\", \"pow\", \"property\", \"range\", \"repr\", \"reversed\", \"round\", \"set\", \"setattr\", \"slice\", \"sorted\", \"staticmethod\", \"str\", \"sum\", \"super\", \"tuple\", \"type\", \"vars\", \"zip\", \"__import__\", \"NotImplemented\", \"Ellipsis\", \"__debug__\"];\n  CodeMirror.registerHelper(\"hintWords\", \"python\", commonKeywords.concat(commonBuiltins).concat([\"exec\", \"print\"]));\n  function top(state) {\n    return state.scopes[state.scopes.length - 1];\n  }\n  CodeMirror.defineMode(\"python\", function (conf, parserConf) {\n    var ERRORCLASS = \"error\";\n    var delimiters = parserConf.delimiters || parserConf.singleDelimiters || /^[\\(\\)\\[\\]\\{\\}@,:`=;\\.\\\\]/;\n    //               (Backwards-compatibility with old, cumbersome config system)\n    var operators = [parserConf.singleOperators, parserConf.doubleOperators, parserConf.doubleDelimiters, parserConf.tripleDelimiters, parserConf.operators || /^([-+*/%\\/&|^]=?|[<>=]+|\\/\\/=?|\\*\\*=?|!=|[~!@]|\\.\\.\\.)/];\n    for (var i = 0; i < operators.length; i++) if (!operators[i]) operators.splice(i--, 1);\n    var hangingIndent = parserConf.hangingIndent || conf.indentUnit;\n    var myKeywords = commonKeywords,\n      myBuiltins = commonBuiltins;\n    if (parserConf.extra_keywords != undefined) myKeywords = myKeywords.concat(parserConf.extra_keywords);\n    if (parserConf.extra_builtins != undefined) myBuiltins = myBuiltins.concat(parserConf.extra_builtins);\n    var py3 = !(parserConf.version && Number(parserConf.version) < 3);\n    if (py3) {\n      // since http://legacy.python.org/dev/peps/pep-0465/ @ is also an operator\n      var identifiers = parserConf.identifiers || /^[_A-Za-z\\u00A1-\\uFFFF][_A-Za-z0-9\\u00A1-\\uFFFF]*/;\n      myKeywords = myKeywords.concat([\"nonlocal\", \"None\", \"aiter\", \"anext\", \"async\", \"await\", \"breakpoint\", \"match\", \"case\"]);\n      myBuiltins = myBuiltins.concat([\"ascii\", \"bytes\", \"exec\", \"print\"]);\n      var stringPrefixes = new RegExp(\"^(([rbuf]|(br)|(rb)|(fr)|(rf))?('{3}|\\\"{3}|['\\\"]))\", \"i\");\n    } else {\n      var identifiers = parserConf.identifiers || /^[_A-Za-z][_A-Za-z0-9]*/;\n      myKeywords = myKeywords.concat([\"exec\", \"print\"]);\n      myBuiltins = myBuiltins.concat([\"apply\", \"basestring\", \"buffer\", \"cmp\", \"coerce\", \"execfile\", \"file\", \"intern\", \"long\", \"raw_input\", \"reduce\", \"reload\", \"unichr\", \"unicode\", \"xrange\", \"None\"]);\n      var stringPrefixes = new RegExp(\"^(([rubf]|(ur)|(br))?('{3}|\\\"{3}|['\\\"]))\", \"i\");\n    }\n    var keywords = wordRegexp(myKeywords);\n    var builtins = wordRegexp(myBuiltins);\n\n    // tokenizers\n    function tokenBase(stream, state) {\n      var sol = stream.sol() && state.lastToken != \"\\\\\";\n      if (sol) state.indent = stream.indentation();\n      // Handle scope changes\n      if (sol && top(state).type == \"py\") {\n        var scopeOffset = top(state).offset;\n        if (stream.eatSpace()) {\n          var lineOffset = stream.indentation();\n          if (lineOffset > scopeOffset) pushPyScope(state);else if (lineOffset < scopeOffset && dedent(stream, state) && stream.peek() != \"#\") state.errorToken = true;\n          return null;\n        } else {\n          var style = tokenBaseInner(stream, state);\n          if (scopeOffset > 0 && dedent(stream, state)) style += \" \" + ERRORCLASS;\n          return style;\n        }\n      }\n      return tokenBaseInner(stream, state);\n    }\n    function tokenBaseInner(stream, state, inFormat) {\n      if (stream.eatSpace()) return null;\n\n      // Handle Comments\n      if (!inFormat && stream.match(/^#.*/)) return \"comment\";\n\n      // Handle Number Literals\n      if (stream.match(/^[0-9\\.]/, false)) {\n        var floatLiteral = false;\n        // Floats\n        if (stream.match(/^[\\d_]*\\.\\d+(e[\\+\\-]?\\d+)?/i)) {\n          floatLiteral = true;\n        }\n        if (stream.match(/^[\\d_]+\\.\\d*/)) {\n          floatLiteral = true;\n        }\n        if (stream.match(/^\\.\\d+/)) {\n          floatLiteral = true;\n        }\n        if (floatLiteral) {\n          // Float literals may be \"imaginary\"\n          stream.eat(/J/i);\n          return \"number\";\n        }\n        // Integers\n        var intLiteral = false;\n        // Hex\n        if (stream.match(/^0x[0-9a-f_]+/i)) intLiteral = true;\n        // Binary\n        if (stream.match(/^0b[01_]+/i)) intLiteral = true;\n        // Octal\n        if (stream.match(/^0o[0-7_]+/i)) intLiteral = true;\n        // Decimal\n        if (stream.match(/^[1-9][\\d_]*(e[\\+\\-]?[\\d_]+)?/)) {\n          // Decimal literals may be \"imaginary\"\n          stream.eat(/J/i);\n          // TODO - Can you have imaginary longs?\n          intLiteral = true;\n        }\n        // Zero by itself with no other piece of number.\n        if (stream.match(/^0(?![\\dx])/i)) intLiteral = true;\n        if (intLiteral) {\n          // Integer literals may be \"long\"\n          stream.eat(/L/i);\n          return \"number\";\n        }\n      }\n\n      // Handle Strings\n      if (stream.match(stringPrefixes)) {\n        var isFmtString = stream.current().toLowerCase().indexOf('f') !== -1;\n        if (!isFmtString) {\n          state.tokenize = tokenStringFactory(stream.current(), state.tokenize);\n          return state.tokenize(stream, state);\n        } else {\n          state.tokenize = formatStringFactory(stream.current(), state.tokenize);\n          return state.tokenize(stream, state);\n        }\n      }\n      for (var i = 0; i < operators.length; i++) if (stream.match(operators[i])) return \"operator\";\n      if (stream.match(delimiters)) return \"punctuation\";\n      if (state.lastToken == \".\" && stream.match(identifiers)) return \"property\";\n      if (stream.match(keywords) || stream.match(wordOperators)) return \"keyword\";\n      if (stream.match(builtins)) return \"builtin\";\n      if (stream.match(/^(self|cls)\\b/)) return \"variable-2\";\n      if (stream.match(identifiers)) {\n        if (state.lastToken == \"def\" || state.lastToken == \"class\") return \"def\";\n        return \"variable\";\n      }\n\n      // Handle non-detected items\n      stream.next();\n      return inFormat ? null : ERRORCLASS;\n    }\n    function formatStringFactory(delimiter, tokenOuter) {\n      while (\"rubf\".indexOf(delimiter.charAt(0).toLowerCase()) >= 0) delimiter = delimiter.substr(1);\n      var singleline = delimiter.length == 1;\n      var OUTCLASS = \"string\";\n      function tokenNestedExpr(depth) {\n        return function (stream, state) {\n          var inner = tokenBaseInner(stream, state, true);\n          if (inner == \"punctuation\") {\n            if (stream.current() == \"{\") {\n              state.tokenize = tokenNestedExpr(depth + 1);\n            } else if (stream.current() == \"}\") {\n              if (depth > 1) state.tokenize = tokenNestedExpr(depth - 1);else state.tokenize = tokenString;\n            }\n          }\n          return inner;\n        };\n      }\n      function tokenString(stream, state) {\n        while (!stream.eol()) {\n          stream.eatWhile(/[^'\"\\{\\}\\\\]/);\n          if (stream.eat(\"\\\\\")) {\n            stream.next();\n            if (singleline && stream.eol()) return OUTCLASS;\n          } else if (stream.match(delimiter)) {\n            state.tokenize = tokenOuter;\n            return OUTCLASS;\n          } else if (stream.match('{{')) {\n            // ignore {{ in f-str\n            return OUTCLASS;\n          } else if (stream.match('{', false)) {\n            // switch to nested mode\n            state.tokenize = tokenNestedExpr(0);\n            if (stream.current()) return OUTCLASS;else return state.tokenize(stream, state);\n          } else if (stream.match('}}')) {\n            return OUTCLASS;\n          } else if (stream.match('}')) {\n            // single } in f-string is an error\n            return ERRORCLASS;\n          } else {\n            stream.eat(/['\"]/);\n          }\n        }\n        if (singleline) {\n          if (parserConf.singleLineStringErrors) return ERRORCLASS;else state.tokenize = tokenOuter;\n        }\n        return OUTCLASS;\n      }\n      tokenString.isString = true;\n      return tokenString;\n    }\n    function tokenStringFactory(delimiter, tokenOuter) {\n      while (\"rubf\".indexOf(delimiter.charAt(0).toLowerCase()) >= 0) delimiter = delimiter.substr(1);\n      var singleline = delimiter.length == 1;\n      var OUTCLASS = \"string\";\n      function tokenString(stream, state) {\n        while (!stream.eol()) {\n          stream.eatWhile(/[^'\"\\\\]/);\n          if (stream.eat(\"\\\\\")) {\n            stream.next();\n            if (singleline && stream.eol()) return OUTCLASS;\n          } else if (stream.match(delimiter)) {\n            state.tokenize = tokenOuter;\n            return OUTCLASS;\n          } else {\n            stream.eat(/['\"]/);\n          }\n        }\n        if (singleline) {\n          if (parserConf.singleLineStringErrors) return ERRORCLASS;else state.tokenize = tokenOuter;\n        }\n        return OUTCLASS;\n      }\n      tokenString.isString = true;\n      return tokenString;\n    }\n    function pushPyScope(state) {\n      while (top(state).type != \"py\") state.scopes.pop();\n      state.scopes.push({\n        offset: top(state).offset + conf.indentUnit,\n        type: \"py\",\n        align: null\n      });\n    }\n    function pushBracketScope(stream, state, type) {\n      var align = stream.match(/^[\\s\\[\\{\\(]*(?:#|$)/, false) ? null : stream.column() + 1;\n      state.scopes.push({\n        offset: state.indent + hangingIndent,\n        type: type,\n        align: align\n      });\n    }\n    function dedent(stream, state) {\n      var indented = stream.indentation();\n      while (state.scopes.length > 1 && top(state).offset > indented) {\n        if (top(state).type != \"py\") return true;\n        state.scopes.pop();\n      }\n      return top(state).offset != indented;\n    }\n    function tokenLexer(stream, state) {\n      if (stream.sol()) {\n        state.beginningOfLine = true;\n        state.dedent = false;\n      }\n      var style = state.tokenize(stream, state);\n      var current = stream.current();\n\n      // Handle decorators\n      if (state.beginningOfLine && current == \"@\") return stream.match(identifiers, false) ? \"meta\" : py3 ? \"operator\" : ERRORCLASS;\n      if (/\\S/.test(current)) state.beginningOfLine = false;\n      if ((style == \"variable\" || style == \"builtin\") && state.lastToken == \"meta\") style = \"meta\";\n\n      // Handle scope changes.\n      if (current == \"pass\" || current == \"return\") state.dedent = true;\n      if (current == \"lambda\") state.lambda = true;\n      if (current == \":\" && !state.lambda && top(state).type == \"py\" && stream.match(/^\\s*(?:#|$)/, false)) pushPyScope(state);\n      if (current.length == 1 && !/string|comment/.test(style)) {\n        var delimiter_index = \"[({\".indexOf(current);\n        if (delimiter_index != -1) pushBracketScope(stream, state, \"])}\".slice(delimiter_index, delimiter_index + 1));\n        delimiter_index = \"])}\".indexOf(current);\n        if (delimiter_index != -1) {\n          if (top(state).type == current) state.indent = state.scopes.pop().offset - hangingIndent;else return ERRORCLASS;\n        }\n      }\n      if (state.dedent && stream.eol() && top(state).type == \"py\" && state.scopes.length > 1) state.scopes.pop();\n      return style;\n    }\n    var external = {\n      startState: function startState(basecolumn) {\n        return {\n          tokenize: tokenBase,\n          scopes: [{\n            offset: basecolumn || 0,\n            type: \"py\",\n            align: null\n          }],\n          indent: basecolumn || 0,\n          lastToken: null,\n          lambda: false,\n          dedent: 0\n        };\n      },\n      token: function token(stream, state) {\n        var addErr = state.errorToken;\n        if (addErr) state.errorToken = false;\n        var style = tokenLexer(stream, state);\n        if (style && style != \"comment\") state.lastToken = style == \"keyword\" || style == \"punctuation\" ? stream.current() : style;\n        if (style == \"punctuation\") style = null;\n        if (stream.eol() && state.lambda) state.lambda = false;\n        return addErr ? style + \" \" + ERRORCLASS : style;\n      },\n      indent: function indent(state, textAfter) {\n        if (state.tokenize != tokenBase) return state.tokenize.isString ? CodeMirror.Pass : 0;\n        var scope = top(state);\n        var closing = scope.type == textAfter.charAt(0) || scope.type == \"py\" && !state.dedent && /^(else:|elif |except |finally:)/.test(textAfter);\n        if (scope.align != null) return scope.align - (closing ? 1 : 0);else return scope.offset - (closing ? hangingIndent : 0);\n      },\n      electricInput: /^\\s*([\\}\\]\\)]|else:|elif |except |finally:)$/,\n      closeBrackets: {\n        triples: \"'\\\"\"\n      },\n      lineComment: \"#\",\n      fold: \"indent\"\n    };\n    return external;\n  });\n  CodeMirror.defineMIME(\"text/x-python\", \"python\");\n  var words = function words(str) {\n    return str.split(\" \");\n  };\n  CodeMirror.defineMIME(\"text/x-cython\", {\n    name: \"python\",\n    extra_keywords: words(\"by cdef cimport cpdef ctypedef enum except \" + \"extern gil include nogil property public \" + \"readonly struct union DEF IF ELIF ELSE\")\n  });\n});"],"sourceRoot":""}