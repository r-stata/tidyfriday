{"version":3,"sources":["../node_modules/_codemirror@5.65.12@codemirror/mode/pascal/pascal.js"],"names":["CodeMirror","defineMode","keywords","str","obj","words","split","i","length","atoms","null","isOperatorChar","tokenComment","stream","state","ch","maybeEnd","next","tokenize","tokenCommentBraces","startState","token","eatSpace","style","quote","startOfLine","skipToEnd","escaped","end","eat","test","eatWhile","cur","current","propertyIsEnumerable","electricChars","defineMIME","mod","__webpack_require__"],"mappings":"+EAWC,SAAAA,GACD,aAEAA,EAAAC,WAAA,oBAOA,IAAAC,EANA,SAAAC,GAGA,IAFA,IAAAC,EAAA,GACAC,EAAAF,EAAAG,MAAA,KACAC,EAAA,EAAqBA,EAAAF,EAAAG,SAAkBD,EAAAH,EAAAC,EAAAE,KAAA,EACvC,OAAAH,EAEAC,CAAA,w9BACAI,EAAA,CACAC,MAAA,GAEAC,EAAA,mBA0DA,SAAAC,EAAAC,EAAAC,GAGA,IAFA,IACAC,EADAC,GAAA,EAEAD,EAAAF,EAAAI,QAAA,CACA,QAAAF,GAAAC,EAAA,CACAF,EAAAI,SAAA,KACA,MAEAF,EAAA,KAAAD,EAEA,gBAEA,SAAAI,EAAAN,EAAAC,GAEA,IADA,IAAAC,EACAA,EAAAF,EAAAI,QACA,QAAAF,EAAoB,CACpBD,EAAAI,SAAA,KACA,MAGA,gBAKA,OACAE,WAAA,WACA,OACAF,SAAA,OAGAG,MAAA,SAAAR,EAAAC,GACA,GAAAD,EAAAS,WAAA,YACA,IAAAC,GAAAT,EAAAI,UA1FA,SAAAL,EAAAC,GACA,IAwCAU,EAxCAT,EAAAF,EAAAI,OACA,QAAAF,GAAAD,EAAAW,YAEA,OADAZ,EAAAa,YACA,OAEA,QAAAX,GAAA,KAAAA,EAEA,OADAD,EAAAI,UAkCAM,EAlCAT,EAmCA,SAAAF,EAAAC,GAIA,IAHA,IACAG,EADAU,GAAA,EAEAC,GAAA,EACA,OAAAX,EAAAJ,EAAAI,SAAA,CACA,GAAAA,GAAAO,IAAAG,EAAA,CACAC,GAAA,EACA,MAEAD,MAAA,MAAAV,EAGA,OADAW,GAAAD,IAAAb,EAAAI,SAAA,MACA,WA9CAJ,EAAAI,SAAAL,EAAAC,GAEA,QAAAC,GAAAF,EAAAgB,IAAA,KAEA,OADAf,EAAAI,SAAAN,EACAA,EAAAC,EAAAC,GAEA,QAAAC,EAEA,OADAD,EAAAI,SAAAC,EACAA,EAAAN,EAAAC,GAEA,sBAAsBgB,KAAAf,GACtB,YAEA,QAAAe,KAAAf,GAEA,OADAF,EAAAkB,SAAA,UACA,SAEA,QAAAhB,GACAF,EAAAgB,IAAA,KAEA,OADAhB,EAAAa,YACA,UAGA,GAAAf,EAAAmB,KAAAf,GAEA,OADAF,EAAAkB,SAAApB,GACA,WAEAE,EAAAkB,SAAA,WACA,IAAAC,EAAAnB,EAAAoB,UACA,OAAA/B,EAAAgC,qBAAAF,GAAA,UACAvB,EAAAyB,qBAAAF,GAAA,OACA,aAmDAnB,EAAAC,GACA,OAAAS,GAGAY,cAAA,QAGAnC,EAAAoC,WAAA,0BArHAC,CAAQC,EAAQ","file":"static/js/77.9e3cfa34.chunk.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\")\n    // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd)\n    // AMD\n    define([\"../../lib/codemirror\"], mod);else\n    // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"pascal\", function () {\n    function words(str) {\n      var obj = {},\n        words = str.split(\" \");\n      for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n      return obj;\n    }\n    var keywords = words(\"absolute and array asm begin case const constructor destructor div do \" + \"downto else end file for function goto if implementation in inherited \" + \"inline interface label mod nil not object of operator or packed procedure \" + \"program record reintroduce repeat self set shl shr string then to type \" + \"unit until uses var while with xor as class dispinterface except exports \" + \"finalization finally initialization inline is library on out packed \" + \"property raise resourcestring threadvar try absolute abstract alias \" + \"assembler bitpacked break cdecl continue cppdecl cvar default deprecated \" + \"dynamic enumerator experimental export external far far16 forward generic \" + \"helper implements index interrupt iocheck local message name near \" + \"nodefault noreturn nostackframe oldfpccall otherwise overload override \" + \"pascal platform private protected public published read register \" + \"reintroduce result safecall saveregisters softfloat specialize static \" + \"stdcall stored strict unaligned unimplemented varargs virtual write\");\n    var atoms = {\n      \"null\": true\n    };\n    var isOperatorChar = /[+\\-*&%=<>!?|\\/]/;\n    function tokenBase(stream, state) {\n      var ch = stream.next();\n      if (ch == \"#\" && state.startOfLine) {\n        stream.skipToEnd();\n        return \"meta\";\n      }\n      if (ch == '\"' || ch == \"'\") {\n        state.tokenize = tokenString(ch);\n        return state.tokenize(stream, state);\n      }\n      if (ch == \"(\" && stream.eat(\"*\")) {\n        state.tokenize = tokenComment;\n        return tokenComment(stream, state);\n      }\n      if (ch == \"{\") {\n        state.tokenize = tokenCommentBraces;\n        return tokenCommentBraces(stream, state);\n      }\n      if (/[\\[\\]\\(\\),;\\:\\.]/.test(ch)) {\n        return null;\n      }\n      if (/\\d/.test(ch)) {\n        stream.eatWhile(/[\\w\\.]/);\n        return \"number\";\n      }\n      if (ch == \"/\") {\n        if (stream.eat(\"/\")) {\n          stream.skipToEnd();\n          return \"comment\";\n        }\n      }\n      if (isOperatorChar.test(ch)) {\n        stream.eatWhile(isOperatorChar);\n        return \"operator\";\n      }\n      stream.eatWhile(/[\\w\\$_]/);\n      var cur = stream.current();\n      if (keywords.propertyIsEnumerable(cur)) return \"keyword\";\n      if (atoms.propertyIsEnumerable(cur)) return \"atom\";\n      return \"variable\";\n    }\n    function tokenString(quote) {\n      return function (stream, state) {\n        var escaped = false,\n          next,\n          end = false;\n        while ((next = stream.next()) != null) {\n          if (next == quote && !escaped) {\n            end = true;\n            break;\n          }\n          escaped = !escaped && next == \"\\\\\";\n        }\n        if (end || !escaped) state.tokenize = null;\n        return \"string\";\n      };\n    }\n    function tokenComment(stream, state) {\n      var maybeEnd = false,\n        ch;\n      while (ch = stream.next()) {\n        if (ch == \")\" && maybeEnd) {\n          state.tokenize = null;\n          break;\n        }\n        maybeEnd = ch == \"*\";\n      }\n      return \"comment\";\n    }\n    function tokenCommentBraces(stream, state) {\n      var ch;\n      while (ch = stream.next()) {\n        if (ch == \"}\") {\n          state.tokenize = null;\n          break;\n        }\n      }\n      return \"comment\";\n    }\n\n    // Interface\n\n    return {\n      startState: function startState() {\n        return {\n          tokenize: null\n        };\n      },\n      token: function token(stream, state) {\n        if (stream.eatSpace()) return null;\n        var style = (state.tokenize || tokenBase)(stream, state);\n        if (style == \"comment\" || style == \"meta\") return style;\n        return style;\n      },\n      electricChars: \"{}\"\n    };\n  });\n  CodeMirror.defineMIME(\"text/x-pascal\", \"pascal\");\n});"],"sourceRoot":""}