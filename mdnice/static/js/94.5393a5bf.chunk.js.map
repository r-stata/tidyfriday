{"version":3,"sources":["../node_modules/_codemirror@5.65.12@codemirror/mode/sieve/sieve.js"],"names":["CodeMirror","defineMode","config","words","str","obj","split","i","length","keywords","atoms","indentUnit","tokenBase","stream","state","quote","ch","next","eat","tokenize","tokenCComment","skipToEnd","escaped","_indent","push","pop","test","eatWhile","cur","current","tokenMultiLineString","propertyIsEnumerable","_multiLineString","sol","eol","eatSpace","peek","maybeEnd","startState","base","baseIndent","token","indent","_textAfter","electricChars","defineMIME","mod","__webpack_require__"],"mappings":"+EAWC,SAAAA,GACD,aAEAA,EAAAC,WAAA,iBAAAC,GACA,SAAAC,EAAAC,GAGA,IAFA,IAAAC,EAAA,GACAF,EAAAC,EAAAE,MAAA,KACAC,EAAA,EAAqBA,EAAAJ,EAAAK,SAAkBD,EAAAF,EAAAF,EAAAI,KAAA,EACvC,OAAAF,EAEA,IAAAI,EAAAN,EAAA,8BACAO,EAAAP,EAAA,kBACAQ,EAAAT,EAAAS,WACA,SAAAC,EAAAC,EAAAC,GACA,IA6FAC,EA7FAC,EAAAH,EAAAI,OACA,QAAAD,GAAAH,EAAAK,IAAA,KAEA,OADAJ,EAAAK,SAAAC,EACAA,EAAAP,EAAAC,GAEA,SAAAE,EAEA,OADAH,EAAAQ,YACA,UAEA,QAAAL,EAEA,OADAF,EAAAK,UAmFAJ,EAnFAC,EAoFA,SAAAH,EAAAC,GAGA,IAFA,IACAE,EADAM,GAAA,EAEA,OAAAN,EAAAH,EAAAI,UACAD,GAAAD,GAAAO,IACAA,MAAA,MAAAN,EAGA,OADAM,IAAAR,EAAAK,SAAAP,GACA,WA3FAE,EAAAK,SAAAN,EAAAC,GAEA,QAAAE,EAKA,OAJAF,EAAAS,QAAAC,KAAA,KAGAV,EAAAS,QAAAC,KAAA,KACA,KAEA,SAAAR,EAEA,OADAF,EAAAS,QAAAC,KAAA,KACA,KAMA,GAJA,KAAAR,IACAF,EAAAS,QAAAE,MACAX,EAAAS,QAAAE,OAEA,MAAAT,EAEA,OADAF,EAAAS,QAAAE,MACA,KAEA,QAAAT,EAAA,YACA,QAAAA,EAAkB,YAClB,gBAAoBU,KAAAV,GAAA,YAGpB,QAAAU,KAAAV,GAGA,OAFAH,EAAAc,SAAA,QACAd,EAAAK,IAAA,YACA,SAIA,QAAAF,EAGA,OAFAH,EAAAc,SAAA,aACAd,EAAAc,SAAA,gBACA,WAEAd,EAAAc,SAAA,MACA,IAAAC,EAAAf,EAAAgB,UAKA,cAAAD,GAAAf,EAAAK,IAAA,MACAJ,EAAAK,SAAAW,EACA,UAEArB,EAAAsB,qBAAAH,GAAA,UACAlB,EAAAqB,qBAAAH,GAAA,OACA,KAEA,SAAAE,EAAAjB,EAAAC,GAGA,OAFAA,EAAAkB,kBAAA,EAEAnB,EAAAoB,OASA,KAAApB,EAAAI,QAAAJ,EAAAqB,QACApB,EAAAkB,kBAAA,EACAlB,EAAAK,SAAAP,GAEA,WAZAC,EAAAsB,WACA,KAAAtB,EAAAuB,QACAvB,EAAAQ,YACA,YAEAR,EAAAQ,YACA,WAQA,SAAAD,EAAAP,EAAAC,GAGA,IAFA,IACAE,EADAqB,GAAA,EAEA,OAAArB,EAAAH,EAAAI,SAAA,CACA,GAAAoB,GAAA,KAAArB,EAAA,CACAF,EAAAK,SAAAP,EACA,MAEAyB,EAAA,KAAArB,EAEA,gBAcA,OACAsB,WAAA,SAAAC,GACA,OACApB,SAAAP,EACA4B,WAAAD,GAAA,EACAhB,QAAA,KAGAkB,MAAA,SAAA5B,EAAAC,GACA,OAAAD,EAAAsB,WAAA,MACArB,EAAAK,UAAAP,GAAAC,EAAAC,IAEA4B,OAAA,SAAA5B,EAAA6B,GACA,IAAAnC,EAAAM,EAAAS,QAAAf,OAGA,OAFAmC,GAAA,KAAAA,EAAA,IAA6CnC,IAC7CA,EAAA,IAAAA,EAAA,GACAA,EAAAG,GAEAiC,cAAA,OAGA5C,EAAA6C,WAAA,6BAjJAC,CAAQC,EAAQ","file":"static/js/94.5393a5bf.chunk.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\")\n    // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd)\n    // AMD\n    define([\"../../lib/codemirror\"], mod);else\n    // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"sieve\", function (config) {\n    function words(str) {\n      var obj = {},\n        words = str.split(\" \");\n      for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n      return obj;\n    }\n    var keywords = words(\"if elsif else stop require\");\n    var atoms = words(\"true false not\");\n    var indentUnit = config.indentUnit;\n    function tokenBase(stream, state) {\n      var ch = stream.next();\n      if (ch == \"/\" && stream.eat(\"*\")) {\n        state.tokenize = tokenCComment;\n        return tokenCComment(stream, state);\n      }\n      if (ch === '#') {\n        stream.skipToEnd();\n        return \"comment\";\n      }\n      if (ch == \"\\\"\") {\n        state.tokenize = tokenString(ch);\n        return state.tokenize(stream, state);\n      }\n      if (ch == \"(\") {\n        state._indent.push(\"(\");\n        // add virtual angel wings so that editor behaves...\n        // ...more sane in case of broken brackets\n        state._indent.push(\"{\");\n        return null;\n      }\n      if (ch === \"{\") {\n        state._indent.push(\"{\");\n        return null;\n      }\n      if (ch == \")\") {\n        state._indent.pop();\n        state._indent.pop();\n      }\n      if (ch === \"}\") {\n        state._indent.pop();\n        return null;\n      }\n      if (ch == \",\") return null;\n      if (ch == \";\") return null;\n      if (/[{}\\(\\),;]/.test(ch)) return null;\n\n      // 1*DIGIT \"K\" / \"M\" / \"G\"\n      if (/\\d/.test(ch)) {\n        stream.eatWhile(/[\\d]/);\n        stream.eat(/[KkMmGg]/);\n        return \"number\";\n      }\n\n      // \":\" (ALPHA / \"_\") *(ALPHA / DIGIT / \"_\")\n      if (ch == \":\") {\n        stream.eatWhile(/[a-zA-Z_]/);\n        stream.eatWhile(/[a-zA-Z0-9_]/);\n        return \"operator\";\n      }\n      stream.eatWhile(/\\w/);\n      var cur = stream.current();\n\n      // \"text:\" *(SP / HTAB) (hash-comment / CRLF)\n      // *(multiline-literal / multiline-dotstart)\n      // \".\" CRLF\n      if (cur == \"text\" && stream.eat(\":\")) {\n        state.tokenize = tokenMultiLineString;\n        return \"string\";\n      }\n      if (keywords.propertyIsEnumerable(cur)) return \"keyword\";\n      if (atoms.propertyIsEnumerable(cur)) return \"atom\";\n      return null;\n    }\n    function tokenMultiLineString(stream, state) {\n      state._multiLineString = true;\n      // the first line is special it may contain a comment\n      if (!stream.sol()) {\n        stream.eatSpace();\n        if (stream.peek() == \"#\") {\n          stream.skipToEnd();\n          return \"comment\";\n        }\n        stream.skipToEnd();\n        return \"string\";\n      }\n      if (stream.next() == \".\" && stream.eol()) {\n        state._multiLineString = false;\n        state.tokenize = tokenBase;\n      }\n      return \"string\";\n    }\n    function tokenCComment(stream, state) {\n      var maybeEnd = false,\n        ch;\n      while ((ch = stream.next()) != null) {\n        if (maybeEnd && ch == \"/\") {\n          state.tokenize = tokenBase;\n          break;\n        }\n        maybeEnd = ch == \"*\";\n      }\n      return \"comment\";\n    }\n    function tokenString(quote) {\n      return function (stream, state) {\n        var escaped = false,\n          ch;\n        while ((ch = stream.next()) != null) {\n          if (ch == quote && !escaped) break;\n          escaped = !escaped && ch == \"\\\\\";\n        }\n        if (!escaped) state.tokenize = tokenBase;\n        return \"string\";\n      };\n    }\n    return {\n      startState: function startState(base) {\n        return {\n          tokenize: tokenBase,\n          baseIndent: base || 0,\n          _indent: []\n        };\n      },\n      token: function token(stream, state) {\n        if (stream.eatSpace()) return null;\n        return (state.tokenize || tokenBase)(stream, state);\n      },\n      indent: function indent(state, _textAfter) {\n        var length = state._indent.length;\n        if (_textAfter && _textAfter[0] == \"}\") length--;\n        if (length < 0) length = 0;\n        return length * indentUnit;\n      },\n      electricChars: \"}\"\n    };\n  });\n  CodeMirror.defineMIME(\"application/sieve\", \"sieve\");\n});"],"sourceRoot":""}