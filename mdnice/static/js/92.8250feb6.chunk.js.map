{"version":3,"sources":["../node_modules/_codemirror@5.65.12@codemirror/mode/scheme/scheme.js"],"names":["CodeMirror","defineMode","makeKeywords","str","obj","words","split","i","length","keywords","indentKeys","stateStack","indent","type","prev","this","pushStack","state","indentStack","binaryMatcher","RegExp","octalMatcher","hexMatcher","decimalMatcher","isBinaryNumber","stream","match","isOctalNumber","isDecimalNumber","backup","backUp","isHexNumber","processEscapedSequence","options","next","escaped","token","mode","startState","indentation","sExprComment","sExprQuote","sol","eatSpace","returnType","maybeEnd","peek","eatWhile","ch","eat","numTest","hasExactness","hasRadix","test","skipToEnd","letter","keyWord","indentTemp","column","propertyIsEnumerable","eol","current","popStack","fold","closeBrackets","pairs","lineComment","defineMIME","mod","__webpack_require__"],"mappings":"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","file":"static/js/92.8250feb6.chunk.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n/**\n * Author: Koh Zi Han, based on implementation by Koh Zi Chun\n * Improved by: Jakub T. Jankiewicz\n */\n\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\")\n    // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd)\n    // AMD\n    define([\"../../lib/codemirror\"], mod);else\n    // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"scheme\", function () {\n    var BUILTIN = \"builtin\",\n      COMMENT = \"comment\",\n      STRING = \"string\",\n      SYMBOL = \"symbol\",\n      ATOM = \"atom\",\n      NUMBER = \"number\",\n      BRACKET = \"bracket\";\n    var INDENT_WORD_SKIP = 2;\n    function makeKeywords(str) {\n      var obj = {},\n        words = str.split(\" \");\n      for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n      return obj;\n    }\n    var keywords = makeKeywords(\"Î» case-lambda call/cc class cond-expand define-class define-values exit-handler field import inherit init-field interface let*-values let-values let/ec mixin opt-lambda override protect provide public rename require require-for-syntax syntax syntax-case syntax-error unit/sig unless when with-syntax and begin call-with-current-continuation call-with-input-file call-with-output-file case cond define define-syntax define-macro defmacro delay do dynamic-wind else for-each if lambda let let* let-syntax letrec letrec-syntax map or syntax-rules abs acos angle append apply asin assoc assq assv atan boolean? caar cadr call-with-input-file call-with-output-file call-with-values car cdddar cddddr cdr ceiling char->integer char-alphabetic? char-ci<=? char-ci<? char-ci=? char-ci>=? char-ci>? char-downcase char-lower-case? char-numeric? char-ready? char-upcase char-upper-case? char-whitespace? char<=? char<? char=? char>=? char>? char? close-input-port close-output-port complex? cons cos current-input-port current-output-port denominator display eof-object? eq? equal? eqv? eval even? exact->inexact exact? exp expt #f floor force gcd imag-part inexact->exact inexact? input-port? integer->char integer? interaction-environment lcm length list list->string list->vector list-ref list-tail list? load log magnitude make-polar make-rectangular make-string make-vector max member memq memv min modulo negative? newline not null-environment null? number->string number? numerator odd? open-input-file open-output-file output-port? pair? peek-char port? positive? procedure? quasiquote quote quotient rational? rationalize read read-char real-part real? remainder reverse round scheme-report-environment set! set-car! set-cdr! sin sqrt string string->list string->number string->symbol string-append string-ci<=? string-ci<? string-ci=? string-ci>=? string-ci>? string-copy string-fill! string-length string-ref string-set! string<=? string<? string=? string>=? string>? string? substring symbol->string symbol? #t tan transcript-off transcript-on truncate values vector vector->list vector-fill! vector-length vector-ref vector-set! with-input-from-file with-output-to-file write write-char zero?\");\n    var indentKeys = makeKeywords(\"define let letrec let* lambda define-macro defmacro let-syntax letrec-syntax let-values let*-values define-syntax syntax-rules define-values when unless\");\n    function stateStack(indent, type, prev) {\n      // represents a state stack object\n      this.indent = indent;\n      this.type = type;\n      this.prev = prev;\n    }\n    function pushStack(state, indent, type) {\n      state.indentStack = new stateStack(indent, type, state.indentStack);\n    }\n    function popStack(state) {\n      state.indentStack = state.indentStack.prev;\n    }\n    var binaryMatcher = new RegExp(/^(?:[-+]i|[-+][01]+#*(?:\\/[01]+#*)?i|[-+]?[01]+#*(?:\\/[01]+#*)?@[-+]?[01]+#*(?:\\/[01]+#*)?|[-+]?[01]+#*(?:\\/[01]+#*)?[-+](?:[01]+#*(?:\\/[01]+#*)?)?i|[-+]?[01]+#*(?:\\/[01]+#*)?)(?=[()\\s;\"]|$)/i);\n    var octalMatcher = new RegExp(/^(?:[-+]i|[-+][0-7]+#*(?:\\/[0-7]+#*)?i|[-+]?[0-7]+#*(?:\\/[0-7]+#*)?@[-+]?[0-7]+#*(?:\\/[0-7]+#*)?|[-+]?[0-7]+#*(?:\\/[0-7]+#*)?[-+](?:[0-7]+#*(?:\\/[0-7]+#*)?)?i|[-+]?[0-7]+#*(?:\\/[0-7]+#*)?)(?=[()\\s;\"]|$)/i);\n    var hexMatcher = new RegExp(/^(?:[-+]i|[-+][\\da-f]+#*(?:\\/[\\da-f]+#*)?i|[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?@[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?|[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?[-+](?:[\\da-f]+#*(?:\\/[\\da-f]+#*)?)?i|[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?)(?=[()\\s;\"]|$)/i);\n    var decimalMatcher = new RegExp(/^(?:[-+]i|[-+](?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)i|[-+]?(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)@[-+]?(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)|[-+]?(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)[-+](?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)?i|(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*))(?=[()\\s;\"]|$)/i);\n    function isBinaryNumber(stream) {\n      return stream.match(binaryMatcher);\n    }\n    function isOctalNumber(stream) {\n      return stream.match(octalMatcher);\n    }\n    function isDecimalNumber(stream, backup) {\n      if (backup === true) {\n        stream.backUp(1);\n      }\n      return stream.match(decimalMatcher);\n    }\n    function isHexNumber(stream) {\n      return stream.match(hexMatcher);\n    }\n    function processEscapedSequence(stream, options) {\n      var next,\n        escaped = false;\n      while ((next = stream.next()) != null) {\n        if (next == options.token && !escaped) {\n          options.state.mode = false;\n          break;\n        }\n        escaped = !escaped && next == \"\\\\\";\n      }\n    }\n    return {\n      startState: function startState() {\n        return {\n          indentStack: null,\n          indentation: 0,\n          mode: false,\n          sExprComment: false,\n          sExprQuote: false\n        };\n      },\n      token: function token(stream, state) {\n        if (state.indentStack == null && stream.sol()) {\n          // update indentation, but only if indentStack is empty\n          state.indentation = stream.indentation();\n        }\n\n        // skip spaces\n        if (stream.eatSpace()) {\n          return null;\n        }\n        var returnType = null;\n        switch (state.mode) {\n          case \"string\":\n            // multi-line string parsing mode\n            processEscapedSequence(stream, {\n              token: \"\\\"\",\n              state: state\n            });\n            returnType = STRING; // continue on in scheme-string mode\n            break;\n          case \"symbol\":\n            // escape symbol\n            processEscapedSequence(stream, {\n              token: \"|\",\n              state: state\n            });\n            returnType = SYMBOL; // continue on in scheme-symbol mode\n            break;\n          case \"comment\":\n            // comment parsing mode\n            var next,\n              maybeEnd = false;\n            while ((next = stream.next()) != null) {\n              if (next == \"#\" && maybeEnd) {\n                state.mode = false;\n                break;\n              }\n              maybeEnd = next == \"|\";\n            }\n            returnType = COMMENT;\n            break;\n          case \"s-expr-comment\":\n            // s-expr commenting mode\n            state.mode = false;\n            if (stream.peek() == \"(\" || stream.peek() == \"[\") {\n              // actually start scheme s-expr commenting mode\n              state.sExprComment = 0;\n            } else {\n              // if not we just comment the entire of the next token\n              stream.eatWhile(/[^\\s\\(\\)\\[\\]]/); // eat symbol atom\n              returnType = COMMENT;\n              break;\n            }\n          default:\n            // default parsing mode\n            var ch = stream.next();\n            if (ch == \"\\\"\") {\n              state.mode = \"string\";\n              returnType = STRING;\n            } else if (ch == \"'\") {\n              if (stream.peek() == \"(\" || stream.peek() == \"[\") {\n                if (typeof state.sExprQuote != \"number\") {\n                  state.sExprQuote = 0;\n                } // else already in a quoted expression\n                returnType = ATOM;\n              } else {\n                stream.eatWhile(/[\\w_\\-!$%&*+\\.\\/:<=>?@\\^~]/);\n                returnType = ATOM;\n              }\n            } else if (ch == '|') {\n              state.mode = \"symbol\";\n              returnType = SYMBOL;\n            } else if (ch == '#') {\n              if (stream.eat(\"|\")) {\n                // Multi-line comment\n                state.mode = \"comment\"; // toggle to comment mode\n                returnType = COMMENT;\n              } else if (stream.eat(/[tf]/i)) {\n                // #t/#f (atom)\n                returnType = ATOM;\n              } else if (stream.eat(';')) {\n                // S-Expr comment\n                state.mode = \"s-expr-comment\";\n                returnType = COMMENT;\n              } else {\n                var numTest = null,\n                  hasExactness = false,\n                  hasRadix = true;\n                if (stream.eat(/[ei]/i)) {\n                  hasExactness = true;\n                } else {\n                  stream.backUp(1); // must be radix specifier\n                }\n\n                if (stream.match(/^#b/i)) {\n                  numTest = isBinaryNumber;\n                } else if (stream.match(/^#o/i)) {\n                  numTest = isOctalNumber;\n                } else if (stream.match(/^#x/i)) {\n                  numTest = isHexNumber;\n                } else if (stream.match(/^#d/i)) {\n                  numTest = isDecimalNumber;\n                } else if (stream.match(/^[-+0-9.]/, false)) {\n                  hasRadix = false;\n                  numTest = isDecimalNumber;\n                  // re-consume the initial # if all matches failed\n                } else if (!hasExactness) {\n                  stream.eat('#');\n                }\n                if (numTest != null) {\n                  if (hasRadix && !hasExactness) {\n                    // consume optional exactness after radix\n                    stream.match(/^#[ei]/i);\n                  }\n                  if (numTest(stream)) returnType = NUMBER;\n                }\n              }\n            } else if (/^[-+0-9.]/.test(ch) && isDecimalNumber(stream, true)) {\n              // match non-prefixed number, must be decimal\n              returnType = NUMBER;\n            } else if (ch == \";\") {\n              // comment\n              stream.skipToEnd(); // rest of the line is a comment\n              returnType = COMMENT;\n            } else if (ch == \"(\" || ch == \"[\") {\n              var keyWord = '';\n              var indentTemp = stream.column(),\n                letter;\n              /**\n              Either\n              (indent-word ..\n              (non-indent-word ..\n              (;something else, bracket, etc.\n              */\n\n              while ((letter = stream.eat(/[^\\s\\(\\[\\;\\)\\]]/)) != null) {\n                keyWord += letter;\n              }\n              if (keyWord.length > 0 && indentKeys.propertyIsEnumerable(keyWord)) {\n                // indent-word\n\n                pushStack(state, indentTemp + INDENT_WORD_SKIP, ch);\n              } else {\n                // non-indent word\n                // we continue eating the spaces\n                stream.eatSpace();\n                if (stream.eol() || stream.peek() == \";\") {\n                  // nothing significant after\n                  // we restart indentation 1 space after\n                  pushStack(state, indentTemp + 1, ch);\n                } else {\n                  pushStack(state, indentTemp + stream.current().length, ch); // else we match\n                }\n              }\n\n              stream.backUp(stream.current().length - 1); // undo all the eating\n\n              if (typeof state.sExprComment == \"number\") state.sExprComment++;\n              if (typeof state.sExprQuote == \"number\") state.sExprQuote++;\n              returnType = BRACKET;\n            } else if (ch == \")\" || ch == \"]\") {\n              returnType = BRACKET;\n              if (state.indentStack != null && state.indentStack.type == (ch == \")\" ? \"(\" : \"[\")) {\n                popStack(state);\n                if (typeof state.sExprComment == \"number\") {\n                  if (--state.sExprComment == 0) {\n                    returnType = COMMENT; // final closing bracket\n                    state.sExprComment = false; // turn off s-expr commenting mode\n                  }\n                }\n\n                if (typeof state.sExprQuote == \"number\") {\n                  if (--state.sExprQuote == 0) {\n                    returnType = ATOM; // final closing bracket\n                    state.sExprQuote = false; // turn off s-expr quote mode\n                  }\n                }\n              }\n            } else {\n              stream.eatWhile(/[\\w_\\-!$%&*+\\.\\/:<=>?@\\^~]/);\n              if (keywords && keywords.propertyIsEnumerable(stream.current())) {\n                returnType = BUILTIN;\n              } else returnType = \"variable\";\n            }\n        }\n        return typeof state.sExprComment == \"number\" ? COMMENT : typeof state.sExprQuote == \"number\" ? ATOM : returnType;\n      },\n      indent: function indent(state) {\n        if (state.indentStack == null) return state.indentation;\n        return state.indentStack.indent;\n      },\n      fold: \"brace-paren\",\n      closeBrackets: {\n        pairs: \"()[]{}\\\"\\\"\"\n      },\n      lineComment: \";;\"\n    };\n  });\n  CodeMirror.defineMIME(\"text/x-scheme\", \"scheme\");\n});"],"sourceRoot":""}