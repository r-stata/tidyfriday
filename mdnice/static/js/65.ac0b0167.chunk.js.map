{"version":3,"sources":["../node_modules/_codemirror@5.65.12@codemirror/mode/lua/lua.js"],"names":["CodeMirror","defineMode","config","parserConfig","indentUnit","wordRE","words","RegExp","join","specials","builtins","keywords","indentTokens","dedentTokens","dedentPartial","readBracket","stream","level","eat","normal","state","quote","ch","next","cur","bracketed","skipToEnd","escaped","test","peek","eatWhile","style","curlev","startState","basecol","indentDepth","token","eatSpace","word","current","indent","textAfter","closing","electricInput","lineComment","blockCommentStart","blockCommentEnd","defineMIME","mod","__webpack_require__"],"mappings":"+EAeC,SAAAA,GACD,aAEAA,EAAAC,WAAA,eAAAC,EAAAC,GACA,IAAAC,EAAAF,EAAAE,WAIA,SAAAC,EAAAC,GACA,WAAAC,OAAA,OAAAD,EAAAE,KAAA,eAEA,IAAAC,EAAAJ,EAAAF,EAAAM,UAAA,IAGAC,EAAAL,EAAA,8sDACAM,EAAAN,EAAA,wJACAO,EAAAP,EAAA,2CACAQ,EAAAR,EAAA,2BACAS,EAZA,IAAAP,OAAA,OAYA,yBAA2D,iBAZ3DC,KAAA,cAaA,SAAAO,EAAAC,GAEA,IADA,IAAAC,EAAA,EACAD,EAAAE,IAAA,QAAAD,EAEA,OADAD,EAAAE,IAAA,KACAD,EAEA,SAAAE,EAAAH,EAAAI,GACA,IAiCAC,EAjCAC,EAAAN,EAAAO,OACA,WAAAD,GAAAN,EAAAE,IAAA,KACAF,EAAAE,IAAA,MAAAF,EAAAE,IAAA,MAAAE,EAAAI,IAAAC,EAAAV,EAAAC,GAAA,YAAAA,EAAAI,IACAJ,EAAAU,YACA,WAEA,KAAAJ,GAAA,KAAAA,GAAAF,EAAAI,KA2BAH,EA3BAC,EA4BA,SAAAN,EAAAI,GAGA,IAFA,IACAE,EADAK,GAAA,EAEA,OAAAL,EAAAN,EAAAO,UACAD,GAAAD,GAAAM,IACAA,MAAA,MAAAL,EAGA,OADAK,IAAAP,EAAAI,IAAAL,GACA,YApCAH,EAAAI,GACA,KAAAE,GAAA,QAAAM,KAAAZ,EAAAa,SAAAT,EAAAI,IAAAC,EAAAV,EAAAC,GAAA,WAAAA,EAAAI,GACA,KAAAQ,KAAAN,IACAN,EAAAc,SAAA,UACA,UAEA,QAAAF,KAAAN,IACAN,EAAAc,SAAA,cACA,YAEA,KAEA,SAAAL,EAAAR,EAAAc,GACA,gBAAAf,EAAAI,GAGA,IAFA,IACAE,EADAU,EAAA,KAEA,OAAAV,EAAAN,EAAAO,SACA,SAAAS,EACA,KAAAV,IAAAU,EAAA,QACW,QAAAV,IAAAU,MAA8B,SAAAV,GAAAU,GAAAf,EAAA,CACzCG,EAAAI,IAAAL,EACA,MACWa,EAAA,KAEX,OAAAD,GAeA,OACAE,WAAA,SAAAC,GACA,OACAA,WAAA,EACAC,YAAA,EACAX,IAAAL,IAGAiB,MAAA,SAAApB,EAAAI,GACA,GAAAJ,EAAAqB,WAAA,YACA,IAAAN,EAAAX,EAAAI,IAAAR,EAAAI,GACAkB,EAAAtB,EAAAuB,UAOA,MANA,YAAAR,IACApB,EAAAiB,KAAAU,GAAAP,EAAA,UAAqDrB,EAAAkB,KAAAU,GAAAP,EAAA,UAAgDtB,EAAAmB,KAAAU,KAAAP,EAAA,eAErG,WAAAA,GAAA,UAAAA,IACAnB,EAAAgB,KAAAU,KAAAlB,EAAAe,YAA2DtB,EAAAe,KAAAU,MAAAlB,EAAAe,aAE3DJ,GAEAS,OAAA,SAAApB,EAAAqB,GACA,IAAAC,EAAA5B,EAAAc,KAAAa,GACA,OAAArB,EAAAc,QAAA9B,GAAAgB,EAAAe,aAAAO,EAAA,OAEAC,cAAA,gCACAC,YAAA,KACAC,kBAAA,OACAC,gBAAA,QAGA9C,EAAA+C,WAAA,oBA1GAC,CAAQC,EAAQ","file":"static/js/65.ac0b0167.chunk.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n// LUA mode. Ported to CodeMirror 2 from Franciszek Wawrzak's\n// CodeMirror 1 mode.\n// highlights keywords, strings, comments (no leveling supported! (\"[==[\")), tokens, basic indenting\n\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\")\n    // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd)\n    // AMD\n    define([\"../../lib/codemirror\"], mod);else\n    // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"lua\", function (config, parserConfig) {\n    var indentUnit = config.indentUnit;\n    function prefixRE(words) {\n      return new RegExp(\"^(?:\" + words.join(\"|\") + \")\", \"i\");\n    }\n    function wordRE(words) {\n      return new RegExp(\"^(?:\" + words.join(\"|\") + \")$\", \"i\");\n    }\n    var specials = wordRE(parserConfig.specials || []);\n\n    // long list of standard functions from lua manual\n    var builtins = wordRE([\"_G\", \"_VERSION\", \"assert\", \"collectgarbage\", \"dofile\", \"error\", \"getfenv\", \"getmetatable\", \"ipairs\", \"load\", \"loadfile\", \"loadstring\", \"module\", \"next\", \"pairs\", \"pcall\", \"print\", \"rawequal\", \"rawget\", \"rawset\", \"require\", \"select\", \"setfenv\", \"setmetatable\", \"tonumber\", \"tostring\", \"type\", \"unpack\", \"xpcall\", \"coroutine.create\", \"coroutine.resume\", \"coroutine.running\", \"coroutine.status\", \"coroutine.wrap\", \"coroutine.yield\", \"debug.debug\", \"debug.getfenv\", \"debug.gethook\", \"debug.getinfo\", \"debug.getlocal\", \"debug.getmetatable\", \"debug.getregistry\", \"debug.getupvalue\", \"debug.setfenv\", \"debug.sethook\", \"debug.setlocal\", \"debug.setmetatable\", \"debug.setupvalue\", \"debug.traceback\", \"close\", \"flush\", \"lines\", \"read\", \"seek\", \"setvbuf\", \"write\", \"io.close\", \"io.flush\", \"io.input\", \"io.lines\", \"io.open\", \"io.output\", \"io.popen\", \"io.read\", \"io.stderr\", \"io.stdin\", \"io.stdout\", \"io.tmpfile\", \"io.type\", \"io.write\", \"math.abs\", \"math.acos\", \"math.asin\", \"math.atan\", \"math.atan2\", \"math.ceil\", \"math.cos\", \"math.cosh\", \"math.deg\", \"math.exp\", \"math.floor\", \"math.fmod\", \"math.frexp\", \"math.huge\", \"math.ldexp\", \"math.log\", \"math.log10\", \"math.max\", \"math.min\", \"math.modf\", \"math.pi\", \"math.pow\", \"math.rad\", \"math.random\", \"math.randomseed\", \"math.sin\", \"math.sinh\", \"math.sqrt\", \"math.tan\", \"math.tanh\", \"os.clock\", \"os.date\", \"os.difftime\", \"os.execute\", \"os.exit\", \"os.getenv\", \"os.remove\", \"os.rename\", \"os.setlocale\", \"os.time\", \"os.tmpname\", \"package.cpath\", \"package.loaded\", \"package.loaders\", \"package.loadlib\", \"package.path\", \"package.preload\", \"package.seeall\", \"string.byte\", \"string.char\", \"string.dump\", \"string.find\", \"string.format\", \"string.gmatch\", \"string.gsub\", \"string.len\", \"string.lower\", \"string.match\", \"string.rep\", \"string.reverse\", \"string.sub\", \"string.upper\", \"table.concat\", \"table.insert\", \"table.maxn\", \"table.remove\", \"table.sort\"]);\n    var keywords = wordRE([\"and\", \"break\", \"elseif\", \"false\", \"nil\", \"not\", \"or\", \"return\", \"true\", \"function\", \"end\", \"if\", \"then\", \"else\", \"do\", \"while\", \"repeat\", \"until\", \"for\", \"in\", \"local\"]);\n    var indentTokens = wordRE([\"function\", \"if\", \"repeat\", \"do\", \"\\\\(\", \"{\"]);\n    var dedentTokens = wordRE([\"end\", \"until\", \"\\\\)\", \"}\"]);\n    var dedentPartial = prefixRE([\"end\", \"until\", \"\\\\)\", \"}\", \"else\", \"elseif\"]);\n    function readBracket(stream) {\n      var level = 0;\n      while (stream.eat(\"=\")) ++level;\n      stream.eat(\"[\");\n      return level;\n    }\n    function normal(stream, state) {\n      var ch = stream.next();\n      if (ch == \"-\" && stream.eat(\"-\")) {\n        if (stream.eat(\"[\") && stream.eat(\"[\")) return (state.cur = bracketed(readBracket(stream), \"comment\"))(stream, state);\n        stream.skipToEnd();\n        return \"comment\";\n      }\n      if (ch == \"\\\"\" || ch == \"'\") return (state.cur = string(ch))(stream, state);\n      if (ch == \"[\" && /[\\[=]/.test(stream.peek())) return (state.cur = bracketed(readBracket(stream), \"string\"))(stream, state);\n      if (/\\d/.test(ch)) {\n        stream.eatWhile(/[\\w.%]/);\n        return \"number\";\n      }\n      if (/[\\w_]/.test(ch)) {\n        stream.eatWhile(/[\\w\\\\\\-_.]/);\n        return \"variable\";\n      }\n      return null;\n    }\n    function bracketed(level, style) {\n      return function (stream, state) {\n        var curlev = null,\n          ch;\n        while ((ch = stream.next()) != null) {\n          if (curlev == null) {\n            if (ch == \"]\") curlev = 0;\n          } else if (ch == \"=\") ++curlev;else if (ch == \"]\" && curlev == level) {\n            state.cur = normal;\n            break;\n          } else curlev = null;\n        }\n        return style;\n      };\n    }\n    function string(quote) {\n      return function (stream, state) {\n        var escaped = false,\n          ch;\n        while ((ch = stream.next()) != null) {\n          if (ch == quote && !escaped) break;\n          escaped = !escaped && ch == \"\\\\\";\n        }\n        if (!escaped) state.cur = normal;\n        return \"string\";\n      };\n    }\n    return {\n      startState: function startState(basecol) {\n        return {\n          basecol: basecol || 0,\n          indentDepth: 0,\n          cur: normal\n        };\n      },\n      token: function token(stream, state) {\n        if (stream.eatSpace()) return null;\n        var style = state.cur(stream, state);\n        var word = stream.current();\n        if (style == \"variable\") {\n          if (keywords.test(word)) style = \"keyword\";else if (builtins.test(word)) style = \"builtin\";else if (specials.test(word)) style = \"variable-2\";\n        }\n        if (style != \"comment\" && style != \"string\") {\n          if (indentTokens.test(word)) ++state.indentDepth;else if (dedentTokens.test(word)) --state.indentDepth;\n        }\n        return style;\n      },\n      indent: function indent(state, textAfter) {\n        var closing = dedentPartial.test(textAfter);\n        return state.basecol + indentUnit * (state.indentDepth - (closing ? 1 : 0));\n      },\n      electricInput: /^\\s*(?:end|until|else|\\)|\\})$/,\n      lineComment: \"--\",\n      blockCommentStart: \"--[[\",\n      blockCommentEnd: \"]]\"\n    };\n  });\n  CodeMirror.defineMIME(\"text/x-lua\", \"lua\");\n});"],"sourceRoot":""}