{"version":3,"sources":["../node_modules/_codemirror@5.65.12@codemirror/mode/twig/twig.js","../node_modules/_codemirror@5.65.12@codemirror/addon/mode/multiplex.js"],"names":["CodeMirror","defineMode","keywords","operator","sign","atom","number","RegExp","join","startState","token","stream","state","ch","peek","incomment","skipTo","eatWhile","skipToEnd","intag","match","instring","next","eat","sol","tokenBase","config","parserConfig","twigInner","getMode","base","multiplexingMode","open","close","mode","parseDelimiters","defineMIME","mod","__webpack_require__","outer","others","Array","prototype","slice","call","arguments","indexOf","string","pattern","from","returnEnd","found","length","m","exec","index","innerActive","inner","startingInner","copyState","curInner","oldContent","this","pos","delimStyle","innerToken","start","innerStyle","cutOff","Infinity","i","other","outerIndent","indent","possibleOuterIndent","Pass","outerToken","textAfter","line","blankLine","electricChars","innerMode"],"mappings":"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","file":"static/js/18.5d8ad5bb.chunk.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\")\n    // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"../../addon/mode/multiplex\"));else if (typeof define == \"function\" && define.amd)\n    // AMD\n    define([\"../../lib/codemirror\", \"../../addon/mode/multiplex\"], mod);else\n    // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"twig:inner\", function () {\n    var keywords = [\"and\", \"as\", \"autoescape\", \"endautoescape\", \"block\", \"do\", \"endblock\", \"else\", \"elseif\", \"extends\", \"for\", \"endfor\", \"embed\", \"endembed\", \"filter\", \"endfilter\", \"flush\", \"from\", \"if\", \"endif\", \"in\", \"is\", \"include\", \"import\", \"not\", \"or\", \"set\", \"spaceless\", \"endspaceless\", \"with\", \"endwith\", \"trans\", \"endtrans\", \"blocktrans\", \"endblocktrans\", \"macro\", \"endmacro\", \"use\", \"verbatim\", \"endverbatim\"],\n      operator = /^[+\\-*&%=<>!?|~^]/,\n      sign = /^[:\\[\\(\\{]/,\n      atom = [\"true\", \"false\", \"null\", \"empty\", \"defined\", \"divisibleby\", \"divisible by\", \"even\", \"odd\", \"iterable\", \"sameas\", \"same as\"],\n      number = /^(\\d[+\\-\\*\\/])?\\d+(\\.\\d+)?/;\n    keywords = new RegExp(\"((\" + keywords.join(\")|(\") + \"))\\\\b\");\n    atom = new RegExp(\"((\" + atom.join(\")|(\") + \"))\\\\b\");\n    function tokenBase(stream, state) {\n      var ch = stream.peek();\n\n      //Comment\n      if (state.incomment) {\n        if (!stream.skipTo(\"#}\")) {\n          stream.skipToEnd();\n        } else {\n          stream.eatWhile(/\\#|}/);\n          state.incomment = false;\n        }\n        return \"comment\";\n        //Tag\n      } else if (state.intag) {\n        //After operator\n        if (state.operator) {\n          state.operator = false;\n          if (stream.match(atom)) {\n            return \"atom\";\n          }\n          if (stream.match(number)) {\n            return \"number\";\n          }\n        }\n        //After sign\n        if (state.sign) {\n          state.sign = false;\n          if (stream.match(atom)) {\n            return \"atom\";\n          }\n          if (stream.match(number)) {\n            return \"number\";\n          }\n        }\n        if (state.instring) {\n          if (ch == state.instring) {\n            state.instring = false;\n          }\n          stream.next();\n          return \"string\";\n        } else if (ch == \"'\" || ch == '\"') {\n          state.instring = ch;\n          stream.next();\n          return \"string\";\n        } else if (stream.match(state.intag + \"}\") || stream.eat(\"-\") && stream.match(state.intag + \"}\")) {\n          state.intag = false;\n          return \"tag\";\n        } else if (stream.match(operator)) {\n          state.operator = true;\n          return \"operator\";\n        } else if (stream.match(sign)) {\n          state.sign = true;\n        } else {\n          if (stream.eat(\" \") || stream.sol()) {\n            if (stream.match(keywords)) {\n              return \"keyword\";\n            }\n            if (stream.match(atom)) {\n              return \"atom\";\n            }\n            if (stream.match(number)) {\n              return \"number\";\n            }\n            if (stream.sol()) {\n              stream.next();\n            }\n          } else {\n            stream.next();\n          }\n        }\n        return \"variable\";\n      } else if (stream.eat(\"{\")) {\n        if (stream.eat(\"#\")) {\n          state.incomment = true;\n          if (!stream.skipTo(\"#}\")) {\n            stream.skipToEnd();\n          } else {\n            stream.eatWhile(/\\#|}/);\n            state.incomment = false;\n          }\n          return \"comment\";\n          //Open tag\n        } else if (ch = stream.eat(/\\{|%/)) {\n          //Cache close tag\n          state.intag = ch;\n          if (ch == \"{\") {\n            state.intag = \"}\";\n          }\n          stream.eat(\"-\");\n          return \"tag\";\n        }\n      }\n      stream.next();\n    }\n    ;\n    return {\n      startState: function startState() {\n        return {};\n      },\n      token: function token(stream, state) {\n        return tokenBase(stream, state);\n      }\n    };\n  });\n  CodeMirror.defineMode(\"twig\", function (config, parserConfig) {\n    var twigInner = CodeMirror.getMode(config, \"twig:inner\");\n    if (!parserConfig || !parserConfig.base) return twigInner;\n    return CodeMirror.multiplexingMode(CodeMirror.getMode(config, parserConfig.base), {\n      open: /\\{[{#%]/,\n      close: /[}#%]\\}/,\n      mode: twigInner,\n      parseDelimiters: true\n    });\n  });\n  CodeMirror.defineMIME(\"text/x-twig\", \"twig\");\n});","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\")\n    // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd)\n    // AMD\n    define([\"../../lib/codemirror\"], mod);else\n    // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.multiplexingMode = function (outer /*, others */) {\n    // Others should be {open, close, mode [, delimStyle] [, innerStyle] [, parseDelimiters]} objects\n    var others = Array.prototype.slice.call(arguments, 1);\n    function indexOf(string, pattern, from, returnEnd) {\n      if (typeof pattern == \"string\") {\n        var found = string.indexOf(pattern, from);\n        return returnEnd && found > -1 ? found + pattern.length : found;\n      }\n      var m = pattern.exec(from ? string.slice(from) : string);\n      return m ? m.index + from + (returnEnd ? m[0].length : 0) : -1;\n    }\n    return {\n      startState: function startState() {\n        return {\n          outer: CodeMirror.startState(outer),\n          innerActive: null,\n          inner: null,\n          startingInner: false\n        };\n      },\n      copyState: function copyState(state) {\n        return {\n          outer: CodeMirror.copyState(outer, state.outer),\n          innerActive: state.innerActive,\n          inner: state.innerActive && CodeMirror.copyState(state.innerActive.mode, state.inner),\n          startingInner: state.startingInner\n        };\n      },\n      token: function token(stream, state) {\n        if (!state.innerActive) {\n          var cutOff = Infinity,\n            oldContent = stream.string;\n          for (var i = 0; i < others.length; ++i) {\n            var other = others[i];\n            var found = indexOf(oldContent, other.open, stream.pos);\n            if (found == stream.pos) {\n              if (!other.parseDelimiters) stream.match(other.open);\n              state.startingInner = !!other.parseDelimiters;\n              state.innerActive = other;\n\n              // Get the outer indent, making sure to handle CodeMirror.Pass\n              var outerIndent = 0;\n              if (outer.indent) {\n                var possibleOuterIndent = outer.indent(state.outer, \"\", \"\");\n                if (possibleOuterIndent !== CodeMirror.Pass) outerIndent = possibleOuterIndent;\n              }\n              state.inner = CodeMirror.startState(other.mode, outerIndent);\n              return other.delimStyle && other.delimStyle + \" \" + other.delimStyle + \"-open\";\n            } else if (found != -1 && found < cutOff) {\n              cutOff = found;\n            }\n          }\n          if (cutOff != Infinity) stream.string = oldContent.slice(0, cutOff);\n          var outerToken = outer.token(stream, state.outer);\n          if (cutOff != Infinity) stream.string = oldContent;\n          return outerToken;\n        } else {\n          var curInner = state.innerActive,\n            oldContent = stream.string;\n          if (!curInner.close && stream.sol()) {\n            state.innerActive = state.inner = null;\n            return this.token(stream, state);\n          }\n          var found = curInner.close && !state.startingInner ? indexOf(oldContent, curInner.close, stream.pos, curInner.parseDelimiters) : -1;\n          if (found == stream.pos && !curInner.parseDelimiters) {\n            stream.match(curInner.close);\n            state.innerActive = state.inner = null;\n            return curInner.delimStyle && curInner.delimStyle + \" \" + curInner.delimStyle + \"-close\";\n          }\n          if (found > -1) stream.string = oldContent.slice(0, found);\n          var innerToken = curInner.mode.token(stream, state.inner);\n          if (found > -1) stream.string = oldContent;else if (stream.pos > stream.start) state.startingInner = false;\n          if (found == stream.pos && curInner.parseDelimiters) state.innerActive = state.inner = null;\n          if (curInner.innerStyle) {\n            if (innerToken) innerToken = innerToken + \" \" + curInner.innerStyle;else innerToken = curInner.innerStyle;\n          }\n          return innerToken;\n        }\n      },\n      indent: function indent(state, textAfter, line) {\n        var mode = state.innerActive ? state.innerActive.mode : outer;\n        if (!mode.indent) return CodeMirror.Pass;\n        return mode.indent(state.innerActive ? state.inner : state.outer, textAfter, line);\n      },\n      blankLine: function blankLine(state) {\n        var mode = state.innerActive ? state.innerActive.mode : outer;\n        if (mode.blankLine) {\n          mode.blankLine(state.innerActive ? state.inner : state.outer);\n        }\n        if (!state.innerActive) {\n          for (var i = 0; i < others.length; ++i) {\n            var other = others[i];\n            if (other.open === \"\\n\") {\n              state.innerActive = other;\n              state.inner = CodeMirror.startState(other.mode, mode.indent ? mode.indent(state.outer, \"\", \"\") : 0);\n            }\n          }\n        } else if (state.innerActive.close === \"\\n\") {\n          state.innerActive = state.inner = null;\n        }\n      },\n      electricChars: outer.electricChars,\n      innerMode: function innerMode(state) {\n        return state.inner ? {\n          state: state.inner,\n          mode: state.innerActive.mode\n        } : {\n          state: state.outer,\n          mode: outer\n        };\n      }\n    };\n  };\n});"],"sourceRoot":""}