this.workbox=this.workbox||{},this.workbox.routing=function(i,u,s,l,o){"use strict";try{self.workbox.v["workbox:routing:3.6.3"]=1}catch(e){}const a=["DELETE","GET","HEAD","PATCH","POST","PUT"];var n=e=>e&&"object"==typeof e?(i.assert.hasMethod(e,"handle",{moduleName:"workbox-routing",className:"Route",funcName:"constructor",paramName:"handler"}),e):(i.assert.isType(e,"function",{moduleName:"workbox-routing",className:"Route",funcName:"constructor",paramName:"handler"}),{handle:e});class h{constructor(e,t,r){i.assert.isType(e,"function",{moduleName:"workbox-routing",className:"Route",funcName:"constructor",paramName:"match"}),r&&i.assert.isOneOf(r,a,{paramName:"method"}),this.handler=n(t),this.match=e,this.method=r||"GET"}}class c extends h{constructor(r,e,t){i.assert.isInstance(r,RegExp,{moduleName:"workbox-routing",className:"RegExpRoute",funcName:"constructor",paramName:"pattern"});super(({url:e})=>{var t=r.exec(e.href);return t?e.origin!==location.origin&&0!==t.index?(u.logger.debug(`The regular expression '${r}' only partially matched `+`against the cross-origin URL '${e}'. RegExpRoute's will only `+"handle cross-origin requests if they match the entire URL."),null):t.slice(1):null},e,t)}}class e{constructor(){this._routes=new Map}handleRequest(o){i.assert.isInstance(o,FetchEvent,{moduleName:"workbox-routing",className:"Router",funcName:"handleRequest",paramName:"event"});const a=new URL(o.request.url);if(a.protocol.startsWith("http")){let r=null,e=null;var s,n=[],t=this._findHandlerAndParams(o,a);if(e=t.handler,s=t.params,r=t.route,e&&(n.push(["Found a route to handle this request:",r]),s&&n.push(["Passing the following params to the route's handler:",s])),!e&&this._defaultHandler&&(n.push("Failed to find a matching route. Falling back to the default handler."),r="[Default Handler]",e=this._defaultHandler),e){u.logger.groupCollapsed("Router is responding to: "+l.getFriendlyURL(a)),n.forEach(e=>{Array.isArray(e)?u.logger.log(...e):u.logger.log(e)}),u.logger.groupCollapsed("View request details here."),u.logger.unprefixed.log(o.request),u.logger.groupEnd(),u.logger.groupEnd();let t;try{t=e.handle({url:a,event:o,params:s})}catch(e){t=Promise.reject(e)}return t=t&&this._catchHandler?t.catch(e=>(u.logger.groupCollapsed("Error thrown when responding to: "+` ${l.getFriendlyURL(a)}. Falling back to Catch Handler.`),u.logger.unprefixed.error("Error thrown by:",r),u.logger.unprefixed.error(e),u.logger.groupEnd(),this._catchHandler.handle({url:a,event:o,err:e}))):t}u.logger.debug("No route found for: "+l.getFriendlyURL(a))}else u.logger.debug("Workbox Router only supports URLs that start with 'http'.")}_findHandlerAndParams(t,r){for(const o of this._routes.get(t.request.method)||[]){let e=o.match({url:r,event:t});if(e)return(Array.isArray(e)&&0===e.length||e.constructor===Object&&0===Object.keys(e).length||!0===e)&&(e=void 0),{route:o,params:e,handler:o.handler}}return{handler:void 0,params:void 0}}setDefaultHandler(e){this._defaultHandler=n(e)}setCatchHandler(e){this._catchHandler=n(e)}registerRoute(e){i.assert.isType(e,"object",{moduleName:"workbox-routing",className:"Router",funcName:"registerRoute",paramName:"route"}),i.assert.hasMethod(e,"match",{moduleName:"workbox-routing",className:"Router",funcName:"registerRoute",paramName:"route"}),i.assert.isType(e.handler,"object",{moduleName:"workbox-routing",className:"Router",funcName:"registerRoute",paramName:"route"}),i.assert.hasMethod(e.handler,"handle",{moduleName:"workbox-routing",className:"Router",funcName:"registerRoute",paramName:"route.handler"}),i.assert.isType(e.method,"string",{moduleName:"workbox-routing",className:"Router",funcName:"registerRoute",paramName:"route.method"}),this._routes.has(e.method)||this._routes.set(e.method,[]),this._routes.get(e.method).push(e)}unregisterRoute(e){if(!this._routes.has(e.method))throw new s.WorkboxError("unregister-route-but-not-found-with-method",{method:e.method});var t=this._routes.get(e.method).indexOf(e);if(!(-1<t))throw new s.WorkboxError("unregister-route-route-not-registered");this._routes.get(e.method).splice(t,1)}}class g extends h{constructor(e,{whitelist:t=[/./],blacklist:r=[]}={}){i.assert.isArrayOfClass(t,RegExp,{moduleName:"workbox-routing",className:"NavigationRoute",funcName:"constructor",paramName:"options.whitelist"}),i.assert.isArrayOfClass(r,RegExp,{moduleName:"workbox-routing",className:"NavigationRoute",funcName:"constructor",paramName:"options.blacklist"}),super((...e)=>this._match(...e),e),this._whitelist=t,this._blacklist=r}_match({event:e,url:t}){if("navigate"===e.request.mode){const r=t.pathname+t.search;if(this._blacklist.some(e=>e.test(r)))u.logger.debug("The navigation route is not being used, since the request URL matches both the whitelist and blacklist.");else{if(this._whitelist.some(e=>e.test(r)))return u.logger.debug("The navigation route is being used."),!0;u.logger.debug("The navigation route is not being used, since the URL being navigated to doesn't match the whitelist.")}}return!1}}var t=Object.freeze({RegExpRoute:c,Route:h,Router:e,NavigationRoute:g});i.assert.isSwEnv("workbox-routing");const r=new class extends e{registerRoute(t,e,r="GET"){let o;if("string"==typeof t){const a=new URL(t,location);if(!t.startsWith("/")&&!t.startsWith("http"))throw new s.WorkboxError("invalid-string",{moduleName:"workbox-routing",className:"DefaultRouter",funcName:"registerRoute",paramName:"capture"});(t.startsWith("http")?a.pathname:t).match(new RegExp("[*:?+]"))&&u.logger.debug("The '$capture' parameter contains an Express-style wildcard character ([*:?+]). Strings are now always interpreted as exact matches; use a RegExp for partial or wildcard matches.");o=new h(({url:e})=>(e.pathname===a.pathname&&e.origin!==a.origin&&u.logger.debug(t+" only partially matches the cross-origin URL "+e+". This route will only handle cross-origin requests if they match the entire URL."),e.href===a.href),e,r)}else if(t instanceof RegExp)o=new c(t,e,r);else if("function"==typeof t)o=new h(t,e,r);else{if(!(t instanceof h))throw new s.WorkboxError("unsupported-route-type",{moduleName:"workbox-routing",className:"DefaultRouter",funcName:"registerRoute",paramName:"capture"});o=t}return super.registerRoute(o),o}registerNavigationRoute(t,e={}){i.assert.isType(t,"string",{moduleName:"workbox-routing",className:"[default export]",funcName:"registerNavigationRoute",paramName:"cachedAssetUrl"});const r=o.cacheNames.getPrecacheName(e.cacheName);e=new g(()=>caches.match(t,{cacheName:r}).then(e=>{if(e)return e;throw new Error(`The cache ${r} did not have an entry for `+t+".")}).catch(e=>(u.logger.debug("Unable to respond to navigation request with cached "+`response: ${e.message}. Falling back to network.`),fetch(t))),{whitelist:e.whitelist,blacklist:e.blacklist});return super.registerRoute(e),e}};return self.addEventListener("fetch",e=>{var t=r.handleRequest(e);t&&e.respondWith(t)}),Object.assign(r,t)}(workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private);