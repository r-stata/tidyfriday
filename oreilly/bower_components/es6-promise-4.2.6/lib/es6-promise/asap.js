let len=0,vertxNext,customSchedulerFn;var asap=function(e,t){queue[len]=e,queue[len+1]=t,2===(len+=2)&&(customSchedulerFn?customSchedulerFn(flush):scheduleFlush())};function setScheduler(e){customSchedulerFn=e}function setAsap(e){asap=e}const browserWindow="undefined"!=typeof window?window:void 0,browserGlobal=browserWindow||{},BrowserMutationObserver=browserGlobal.MutationObserver||browserGlobal.WebKitMutationObserver,isNode="undefined"==typeof self&&"undefined"!=typeof process&&"[object process]"==={}.toString.call(process),isWorker="undefined"!=typeof Uint8ClampedArray&&"undefined"!=typeof importScripts&&"undefined"!=typeof MessageChannel;function useNextTick(){return()=>process.nextTick(flush)}function useVertxTimer(){return void 0!==vertxNext?function(){vertxNext(flush)}:useSetTimeout()}function useMutationObserver(){let e=0;var t=new BrowserMutationObserver(flush);const r=document.createTextNode("");return t.observe(r,{characterData:!0}),()=>{r.data=e=++e%2}}function useMessageChannel(){const e=new MessageChannel;return e.port1.onmessage=flush,()=>e.port2.postMessage(0)}function useSetTimeout(){const e=setTimeout;return()=>e(flush,1)}const queue=new Array(1e3);function flush(){for(let e=0;e<len;e+=2)(0,queue[e])(queue[e+1]),queue[e]=void 0,queue[e+1]=void 0;len=0}function attemptVertx(){try{var e=Function("return this")().require("vertx");return vertxNext=e.runOnLoop||e.runOnContext,useVertxTimer()}catch(e){return useSetTimeout()}}let scheduleFlush;scheduleFlush=(isNode?useNextTick:BrowserMutationObserver?useMutationObserver:isWorker?useMessageChannel:void 0===browserWindow&&"function"==typeof require?attemptVertx:useSetTimeout)();export{asap,setScheduler,setAsap};