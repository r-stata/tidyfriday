import{objectOrFunction,isFunction}from"./utils";import{asap}from"./asap";import originalThen from"./then";import originalResolve from"./promise/resolve";const PROMISE_ID=Math.random().toString(36).substring(2);function noop(){}const PENDING=void 0,FULFILLED=1,REJECTED=2,TRY_CATCH_ERROR={error:null};function selfFulfillment(){return new TypeError("You cannot resolve a promise with itself")}function cannotReturnOwn(){return new TypeError("A promises callback cannot return that same promise.")}function getThen(e){try{return e.then}catch(e){return TRY_CATCH_ERROR.error=e,TRY_CATCH_ERROR}}function tryThen(e,r,n,t){try{e.call(r,n,t)}catch(e){return e}}function handleForeignThenable(e,t,o){asap(r=>{var n=!1,e=tryThen(o,t,e=>{n||(n=!0,(t!==e?resolve:fulfill)(r,e))},e=>{n||(n=!0,reject(r,e))},"Settle: "+(r._label||" unknown promise"));!n&&e&&(n=!0,reject(r,e))},e)}function handleOwnThenable(r,e){e._state===FULFILLED?fulfill(r,e._result):e._state===REJECTED?reject(r,e._result):subscribe(e,void 0,e=>resolve(r,e),e=>reject(r,e))}function handleMaybeThenable(e,r,n){r.constructor===e.constructor&&n===originalThen&&r.constructor.resolve===originalResolve?handleOwnThenable(e,r):n===TRY_CATCH_ERROR?(reject(e,TRY_CATCH_ERROR.error),TRY_CATCH_ERROR.error=null):void 0!==n&&isFunction(n)?handleForeignThenable(e,r,n):fulfill(e,r)}function resolve(e,r){e===r?reject(e,selfFulfillment()):objectOrFunction(r)?handleMaybeThenable(e,r,getThen(r)):fulfill(e,r)}function publishRejection(e){e._onerror&&e._onerror(e._result),publish(e)}function fulfill(e,r){e._state===PENDING&&(e._result=r,e._state=FULFILLED,0!==e._subscribers.length&&asap(publish,e))}function reject(e,r){e._state===PENDING&&(e._state=REJECTED,e._result=r,asap(publishRejection,e))}function subscribe(e,r,n,t){var o=e["_subscribers"],i=o["length"];e._onerror=null,o[i]=r,o[i+FULFILLED]=n,o[i+REJECTED]=t,0===i&&e._state&&asap(publish,e)}function publish(e){var r=e._subscribers,n=e._state;if(0!==r.length){var t,o,i=e._result;for(let e=0;e<r.length;e+=3)t=r[e],o=r[e+n],t?invokeCallback(n,t,o,i):o(i);e._subscribers.length=0}}function tryCatch(e,r){try{return e(r)}catch(e){return TRY_CATCH_ERROR.error=e,TRY_CATCH_ERROR}}function invokeCallback(e,r,n,t){let o=isFunction(n),i,l,s,u;if(o){if((i=tryCatch(n,t))===TRY_CATCH_ERROR?(u=!0,l=i.error,i.error=null):s=!0,r===i)return void reject(r,cannotReturnOwn())}else i=t,s=!0;r._state===PENDING&&(o&&s?resolve(r,i):u?reject(r,l):e===FULFILLED?fulfill(r,i):e===REJECTED&&reject(r,i))}function initializePromise(r,e){try{e(function(e){resolve(r,e)},function(e){reject(r,e)})}catch(e){reject(r,e)}}let id=0;function nextId(){return id++}function makePromise(e){e[PROMISE_ID]=id++,e._state=void 0,e._result=void 0,e._subscribers=[]}export{PROMISE_ID,nextId,makePromise,getThen,noop,resolve,reject,fulfill,subscribe,publish,publishRejection,initializePromise,invokeCallback,FULFILLED,REJECTED,PENDING,handleMaybeThenable};