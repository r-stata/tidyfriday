import{isArray,isMaybeThenable}from"./utils";import{noop,reject,fulfill,subscribe,FULFILLED,REJECTED,PENDING,getThen,handleMaybeThenable}from"./-internal";import then from"./then";import Promise from"./promise";import originalResolve from"./promise/resolve";import originalThen from"./then";import{makePromise,PROMISE_ID}from"./-internal";function validationError(){return new Error("Array Methods must be provided an Array")}export default class Enumerator{constructor(t,e){this._instanceConstructor=t,this.promise=new t(noop),this.promise[PROMISE_ID]||makePromise(this.promise),isArray(e)?(this.length=e.length,this._remaining=e.length,this._result=new Array(this.length),0!==this.length&&(this.length=this.length||0,this._enumerate(e),0!==this._remaining)||fulfill(this.promise,this._result)):reject(this.promise,validationError())}_enumerate(e){for(let t=0;this._state===PENDING&&t<e.length;t++)this._eachEntry(e[t],t)}_eachEntry(e,t){var i,r,s=this._instanceConstructor,n=s["resolve"];n===originalResolve?(i=getThen(e))===originalThen&&e._state!==PENDING?this._settledAt(e._state,t,e._result):"function"!=typeof i?(this._remaining--,this._result[t]=e):s===Promise?(r=new s(noop),handleMaybeThenable(r,e,i),this._willSettleAt(r,t)):this._willSettleAt(new s(t=>t(e)),t):this._willSettleAt(n(e),t)}_settledAt(t,e,i){var r=this["promise"];r._state===PENDING&&(this._remaining--,t===REJECTED?reject(r,i):this._result[e]=i),0===this._remaining&&fulfill(r,this._result)}_willSettleAt(t,e){let i=this;subscribe(t,void 0,t=>i._settledAt(FULFILLED,e,t),t=>i._settledAt(REJECTED,e,t))}}